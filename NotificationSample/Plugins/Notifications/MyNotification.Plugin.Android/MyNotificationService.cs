using System;
using System.Collections.Generic;
using Android.App;
using Android.Content;
using Android.OS;

namespace MyNotification.Plugin.Android
{
    [Service]
	public class MyNotificationService : IntentService
	{
		static PowerManager.WakeLock sWakeLock;
		static object LOCK = new object();


		public static void RunIntentInService(Context context, Intent intent)
		{
			lock (LOCK)
			{
				if (sWakeLock == null)
				{
					// This is called from BroadcastReceiver, there is no init.
					var pm = PowerManager.FromContext(context);
					sWakeLock = pm.NewWakeLock (
						WakeLockFlags.Partial, GetTag);
				}
			}

			sWakeLock.Acquire();
			intent.SetClass(context, typeof(MyNotificationService));
			context.StartService(intent);
		}

		private static string GetTag
		{
			get
			{
				if (String.IsNullOrEmpty (MyPushNotification.NotificationTagKey) == true) {
					return "AppName";
				}
				return String.IsNullOrEmpty (MyPushNotification.NotificationTagKey) ? "AppName" : MyPushNotification.NotificationTagKey;
			}
		}

		protected override void OnHandleIntent(Intent intent)
		{
			try
			{
				Context context = this.ApplicationContext;
				if (context != null && intent != null)
				{
					string action = intent.Action;
					var registrationId = intent.GetStringExtra(MyPlugConstants.EXTRA_REGISTRATION_ID);
					var error = intent.GetStringExtra(MyPlugConstants.EXTRA_ERROR);
					var unregistered = intent.GetStringExtra(MyPlugConstants.EXTRA_UNREGISTERED);

					if (String.IsNullOrEmpty(error) == false)
					{
						if (String.Compare(error, MyPlugConstants.ERROR_SERVICE_NOT_AVAILABLE, true) == 0)
						{
							int backoffTimeMs = GetBackoff();
							int nextAttempt = backoffTimeMs / 2 + new Random().Next(backoffTimeMs);
		
							var retryIntent = new Intent(MyPlugConstants.INTENT_FROM_GCM_LIBRARY_RETRY);
							retryIntent.PutExtra(MyPlugConstants.EXTRA_TOKEN, MyPlugConstants.TOKEN);
	
							var retryPendingIntent = PendingIntent.GetBroadcast(context, 0, retryIntent, PendingIntentFlags.OneShot);
	
							var am = AlarmManager.FromContext(context);
							am.Set(AlarmType.ElapsedRealtime, SystemClock.ElapsedRealtime() + nextAttempt, retryPendingIntent);
	
							// Next retry should wait longer.
							if (backoffTimeMs < MyPlugConstants.MAX_BACKOFF_MS)
							{
								SetBackoff(backoffTimeMs * 2);
							}
						}
						else
						{
							MyPushNotification.PushNotificationListener.OnError(new Exception(error));
						}
					}
					else if (String.Compare(action, MyPlugConstants.GCM_Registeration, true) == 0)
					{
						if (unregistered != null)
						{
							//var oldID = GetRegistrationId();
							MyPushNotification.PushNotificationListener.OnUnregistered(MyPushNotification.Current.Token);
							MyPushNotification.PushNotificationListener.StoreRegistrationId("");
						}
						else
						{
							if (String.IsNullOrEmpty(registrationId) == false)
							{
								MyPushNotification.PushNotificationListener.StoreRegistrationId(registrationId);	
								ResetBackoff();
								MyPushNotification.PushNotificationListener.OnRegistered(registrationId);
							}
							else
							{
								MyPushNotification.PushNotificationListener.OnError(new Exception("MyNotificationService/OnHandleIntent register yes, but registeration ID is blank"));
							}
						}
					}
					else if (String.Compare(action, MyPlugConstants.GCM_Message, true) == 0)
					{
						// got a message. do something with it
						HandleMessage(context, intent);
					}
					else if (String.Compare(action, MyPlugConstants.INTENT_FROM_GCM_LIBRARY_RETRY, true) == 0)
					{
						var token = intent.GetStringExtra(MyPlugConstants.EXTRA_TOKEN);
	
						if (!string.IsNullOrEmpty(token) && !(MyPlugConstants.TOKEN.Equals(token)))
						{
							// make sure intent was generated by this class, not by a
							// malicious app.
							return;
						}
							
						MyPushNotification.PushNotificationListener.RetryRegister();

					}
					else if (String.Compare(action, MyPlugConstants.GCM_BOOTCOMPLETED, true) == 0)			
					{
						// ignore this. 
					}
					else
					{
						// error occurred
						MyPushNotification.PushNotificationListener.OnError (new Exception("gcm action missed\r\n" + action));
					}
				}
			}
			catch(Exception ex) {
				MyPushNotification.PushNotificationListener.OnError (ex);
			}
			finally
			{
				lock (LOCK)
				{
					try
					{
						//Sanity check for null as this is a public method
						if (sWakeLock != null && sWakeLock.IsHeld)
						{
							sWakeLock.Release();
						}
					}
					catch
					{ 
					}
				}
			}
		}

		private void HandleMessage(Context context, Intent intent)
		{
			if (intent != null && intent.Extras != null)
			{
				try
				{
					var parameters = new Dictionary<string, string>();
					foreach (var key in intent.Extras.KeySet())
					{
						var value = intent.Extras.Get(key).ToString();
						parameters.Add(key, value);                      
					}

					MyPushNotification.PushNotificationListener.OnMessage(parameters); 
				}
				catch (Exception ex) {		
					MyPushNotification.PushNotificationListener.OnError (ex);
				}
			}
		}

		internal static void ResetBackoff()
		{
			SetBackoff(MyPlugConstants.DEFAULT_BACKOFF_MS);
		}

		internal static int GetBackoff()
		{
			var prefs = MyPushNotification.GCMPrefs;
			return prefs.GetInt (MyPlugConstants.BACKOFF_MS, MyPlugConstants.DEFAULT_BACKOFF_MS);
		}

		internal static void SetBackoff(int backoff)
		{
			var prefs = MyPushNotification.GCMPrefs;
			var editor = prefs.Edit();
			editor.PutInt(MyPlugConstants.BACKOFF_MS, backoff);
			editor.Apply ();
		}

	}
}

